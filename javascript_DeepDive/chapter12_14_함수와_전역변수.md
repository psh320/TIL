## Chapter 12 함수

---

**함수는 일련의 과정을 문(statement) 으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.**

함수를 사용하는 이유

- 코드의 재사용
- 유지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성

함수 리터럴의 구성 요소

![Screenshot 2022-09-08 at 3.14.11 PM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92f32efb-a52e-4303-a196-8cc52468ea99/Screenshot_2022-09-08_at_3.14.11_PM.png)

**\*함수는 객체다**. 일반 객체는 호출 할수 없지만 함수는 호출 할 수 있다. 함수가 객체라는 사실은 다른 언어와 구별되는 자바스크립트의 중요한 특징이다. 이특징을 제대로 알아야 함수를 이해하기 쉽다. 18장에서 더 자세히 다룬다.\*

### 함수 정의

함수를 호출하기전에 인수받을 매개변수와 실행할문들, 반환점을 정의 해야한다. 현재 자바스크립트에서 함수를 정의하는 방법은 총 4가지가 있다.

![Screenshot 2022-09-08 at 3.18.00 PM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1ff2bffa-6bc0-4960-b5ae-f9d1f852bf72/Screenshot_2022-09-08_at_3.18.00_PM.png)

### 함수 선언문 & 함수 표현식

1. 함수 선언문은 함수이름을 생략할 수 없다.
2. 함수 선언문은 표현식이 아닌 문이다.
3. 함수 리터럴은 중의적인 코드이다.

예시로, ‘{ }’ 이 코드는 객체를 만들때 쓰기도 하지만 함수를 만들때 블록(스코프)을 지정하는데 쓰기도 한다, 자바스크립트는 유동적으로 문맥을 살피고 자기가 알아서 변형해서 바꾸는데 함수 리터럴도 중의적인 코드이다.

```tsx
function foo() {
  console.log("foo");
}
foo(); // 작동함
//자바스크립트는 함수 선언문이라 판단하면 이렇게 알아서 아래처럼 바꾼다 (foo 라는 식별자 생성)
var foo = function foo() {
  console.log("foo");
};

(function bar() {
  console.log("bar");
});
bar(); // 작동안함
//() 안에 있어서 함수 선언문이 아닌 표현식으로 인식해서 식별자가 생성되지 않는다
```

_foo 는 함수 선언문으로 작동 하고, bar 는 함수 리터럴 표현식으로 작동함._

**자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.**

함수는 값처럼 **변수에 할당** 할수도, **프로퍼티의 값**이 될수도, **배열의 요소**가 될수있다. 값의 성질을 갖는 객체를 **일급 객체**라고한다. **자바스크립트의 함수는 일급 객체다**.

### 함수 생성 시점과 함수 호이스팅

```tsx
//함수 참조
console.dir(add); // f add(x,y)
console.dir(sub); // undefined

//함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

//함수 선언문
function add(x, y) {
  return x + y;
}

//함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.

**함수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라 한다.**

**함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는것이 아니라 변수 호이스팅이 발생한다. (undefined로 초기 세팅 후 런타임에 함수 할당함).**

### 화살표 함수

ES6에서 도입된 화살표 함수는 항상 익명 함수이다. 함수선언문/함수표현식 보다 뭔가 좀더 간략한 방법을 사용하는데 나중에 더 자세히 나온다. (26.3절)

```tsx
//화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

### 참조에 의한 전달과 외부 상태의 변경

![Screenshot 2022-09-08 at 4.45.47 PM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab10eb92-7bae-4f11-800d-37c2d236ed9f/Screenshot_2022-09-08_at_4.45.47_PM.png)

함수에 매개변수로 원시 타입 변수와 객채 타입 변수를 넣고 함수 안에서 바꾼다면, 원시 타입 변수의 원본은 안바뀌지만, 객체는 바뀐다.

이걸 방지하기 위해서는 객채의 상태 변경을 아예 하지 않던가, 객체의 방어적 복사를 통해 원본 객체를 완전히 복제, 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다 _(리액트에서 상태변경할때 [… , ] 이걸로 하는 이유인듯)_

### 다양한 함수 형태

1. 즉시 실행 함수 - 함수 정의와 동시에 즉시 호출되는 함수, 한번만 호출되며 다시 호출 할수 없다.

   ```tsx
   (function () {
     var a = 3;
     var b = 5;
     return a * b;
   })();
   ```

   즉시 실행 함수는 그룹 연산자 ( )로 감싸야한다.

2. 재귀함수
3. 중첩함수
4. 콜백함수
5. 순수 함수와 비순수 함수

## Chapter 14 전역 변수의 문제점

---

문제점들

- 암묵적 결합
  - 모든코드가 전역 변수를 참조하고 변경할수있는 암묵적 결합 발생. 코드의 가독성이 나빠지고 의도치 않은 상태변경이 생길 수 있다.
- 긴 생명 주기
  - 전역 변수는 생명 주기가 길다. 메모리 리소스 역시 오랜 기간 소비하고 전역변수 상태가 의도치않게 바뀌거나 중복 선언 될 가능성도 있다.
- 스코프 체인상에서 종점에 존재
  - 변수를 검색할 때 전역변수가 가장 마지막에 검색된다. **전역 변수의 검색 속도가 가장 느리다.**
- 네임스페이스 오염
  - 파일이 분리되어있어도 하나의 전역 스코프를 공유하기때문에 동일한 이름을 가진 전역 변수가있다면 예상치 못한 결과를 가져올 수 있다.
