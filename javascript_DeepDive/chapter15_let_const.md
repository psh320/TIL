## Chapter 15 let, const 키워드와 블록 레벨 스코프

---

### var 키워드의 문제점

- 변수 중복 선언 허용
  - 의도치않게 변수에 새로운 값을 할당 하여 기존의 변수 값을 변경 시킬수도 있음.
- 함수 레벨 스코프
  - 전역 변수를 남발할 가능성이 높음.
- 변수 호이스팅
  - 변수 선언문 이전에 변수를 참조하는것은 가독성이 떨어지고 오류를 발생 시킬 수 있다.

### **let 키워드**

- 변수 중복 선언 금지
  - var 키워드랑 다르게 이름이 같은 변수를 중복 선언하면 문법 에러가 발생한다.
- 블록 레벨 스코프
  - let으로 선언한 변수는 모든 블록 코드(함수, if문, while문 등)을 지역 스코프로 인정한다.
- 변수 호이스팅

  - var과 다르게 변수호이스팅이 동작하지 않는다. **let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다.**
    let과 var의 변수 호이스팅 차이점

  ```tsx
  // var 키워드로 선언한 변수는 런타임 이전에 선언 단계와 초기화 단계가 실행된다.
  // 따라서 변수 선언문 이전에 변수를 참조할 수 있다.
  console.log(foo); // undefined

  var foo;
  console.log(foo); // undefined

  foo = 1;
  console.log(foo); // 1
  ---------------------------------------------------------------------
  // let 키워드 => 런타임 이전에 선언 단계가 실행된다. 아직 변수가 초기화 되지 않았다.
  // 초기화 이전의 일시적 사각지대에서는 변수를 참조할 수 없다.
  console.log(foo); // ReferenceError: foo is not defined

  let foo; // 변수 선언문에서 초기화 단계가 실행된다.
  console.log(foo); // undefined

  foo = 1; // 할당문에서 할당 단계가 실행된다.
  console.log(foo); // 1
  ```

### const 키워드

- 선언과 초기화

  **const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.**

  ```tsx
  const foo; // syntaxError: Missing initializer in const declaration.
  const foo = 1; // 선언과 초기화를 동시에 꼭 해줘야 한다.
  ```

  const는 let과 마찬가지로 **블록 레벨 스코프**를 갖고, **변수 호이스팅**이 발생하지 않는 것 처럼 작동한다.

- 재할당 금지
  - const 키워드로 선언한 변수는 재할당이 금지 된다.
- 상수
  - const 키워드로 원시값을 넣어 상수를 선언하면 재할당도 금지되어 유지보수하기 좋다
  - 하지만 const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.
  - const 키워드는 재할당을 금지할 뿐 “불변"을 의미하지는 않는다.

### var vs. let vs. const

- ES6을 사용한다면 var 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시값과 객체에는 const 키워드를 사용한다. const키워드는 재할당이 금지하므로 var, let 키워드 보다 안전하다.
